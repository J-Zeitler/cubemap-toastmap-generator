{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index.js","src/cubeMapViewer.js","src/display.js","src/octahedronGeometry.js","src/quadRenderer.js","src/shaders/index.js","src/zipper.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"proj.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nthis.shaders = require('./shaders');\nthis.OctahedronGeometry = require('./octahedronGeometry');\nthis.CubeMapViewer = require('./cubeMapViewer');\nthis.QuadRenderer = require('./quadRenderer');\n\nthis.Display = require('./display');\n\n// this.MercatorReprojector = require('mercatorReprojector');\n// this.EquirectangularReprojector = require('./equirectangularReprojector');\n","'use strict';\n\nvar QuadRenderer = require('./quadRenderer');\nvar Zipper = require('./zipper');\n\nvar CubeVert = require('./shaders').cubeVert;\nvar CubeFrag = require('./shaders').cubeFrag;\n\n/**\n * Order of children is:\n *\n * 0,   1,    2,    3,     4,     5\n * top, left, back, right, front, bottom\n *\n */\nvar CubeMapViewer = function (map) {\n  THREE.Object3D.call(this);\n\n  this.map = map;\n  if (!(this.map instanceof THREE.WebGLRenderTargetCube)) {\n    throw \"CubeMapViewer: needs a 'THREE.WebGLRenderTargetCube' to construct\";\n  }\n\n  this.quadRenderer = new QuadRenderer();\n\n  var quadMaterial = new THREE.ShaderMaterial({\n    vertexShader: CubeVert,\n    fragmentShader: CubeFrag,\n    uniforms: {\n      cubemap: {type: 't', value: map},\n      side: {type: 'v3', value: new THREE.Vector3()}\n    }\n  });\n\n  // top\n  var mat = quadMaterial.clone();\n  mat.uniforms.side.value = new THREE.Vector3(0, 1, 0);\n  var quad = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry(2, 2, 1, 1),\n    mat\n  );\n\n  this.add(quad);\n  quad.position.x = 0;\n  quad.position.y = 2;\n\n  // left\n  mat = quadMaterial.clone();\n  mat.uniforms.side.value = new THREE.Vector3(1, 0, 0);\n  quad = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry(2, 2, 1, 1),\n    mat\n  );\n  this.add(quad);\n  quad.position.x = -2;\n  quad.position.y = 0;\n\n  // back\n  mat = quadMaterial.clone();\n  mat.uniforms.side.value = new THREE.Vector3(0, 0, -1);\n  quad = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry(2, 2, 1, 1),\n    mat\n  );\n  this.add(quad);\n  quad.position.x = 0;\n  quad.position.y = 0;\n\n  // right\n  mat = quadMaterial.clone();\n  mat.uniforms.side.value = new THREE.Vector3(-1, 0, 0);\n  quad = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry(2, 2, 1, 1),\n    mat\n  );\n  this.add(quad);\n  quad.position.x = 2;\n  quad.position.y = 0;\n\n  // front\n  mat = quadMaterial.clone();\n  mat.uniforms.side.value = new THREE.Vector3(0, 0, 1);\n  quad = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry(2, 2, 1, 1),\n    mat\n  );\n  this.add(quad);\n  quad.position.x = 4;\n  quad.position.y = 0;\n\n  // bottom\n  mat = quadMaterial.clone();\n  mat.uniforms.side.value = new THREE.Vector3(0, -1, 0);\n  quad = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry(2, 2, 1, 1),\n    mat\n  );\n  this.add(quad);\n  quad.position.x = 0;\n  quad.position.y = -2;\n};\n\nCubeMapViewer.prototype = Object.create(THREE.Object3D.prototype);\n\nCubeMapViewer.prototype.renderToImages = function (renderer, faceRes, done, ctx) {\n  var faceData = [];\n  this.children.forEach(function (face) {\n    faceData.push(this.quadRenderer.renderQuad(renderer, face, faceRes));\n  }, this);\n\n  Zipper.zipImages(faceData, CubeMapViewer.id, CubeMapViewer.faceNames, function (zipBlob) {\n    saveAs(zipBlob, CubeMapViewer.id + '.zip');\n    done.call(ctx);\n  }, this);\n};\n\n/**\n * Static\n */\n\nCubeMapViewer.id = 'cubemap';\nCubeMapViewer.faceNames = ['py.png', 'nx.png', 'pz.png', 'px.png', 'nz.png', 'ny.png'];\n\nmodule.exports = CubeMapViewer;\n","'use strict';\n\nvar ToastVert = require('./shaders').toastVert;\nvar ToastFrag = require('./shaders').toastFrag;\n\nvar CubeVert = require('./shaders').cubeVert;\nvar CubeFrag = require('./shaders').cubeFrag;\n\nvar CubeMapViewer = require('./cubeMapViewer');\nvar QuadRenderer = require('./quadRenderer');\n\nvar Display = function (canvasContainer) {\n  this.container = canvasContainer;\n  this.sphereOffsetAngle = 0.5*Math.PI;\n  this.quadRenderer = new QuadRenderer();\n};\n\nDisplay.prototype.init = function (done, ctx) {\n  this.camera = new THREE.PerspectiveCamera(90, this.container.offsetWidth/this.container.offsetHeight, 0.1, 100);\n  this.camera.position.set(0, 0, 3);\n  this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n\n  this.scene = new THREE.Scene();\n  this.cubeScene = new THREE.Scene();\n\n  this.renderer = new THREE.WebGLRenderer();\n  this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n  this.renderer.setClearColor(0xffffff, 1);\n  this.container.appendChild(this.renderer.domElement);\n\n  this.cubeCamera = new THREE.CubeCamera(0.1, 10, 1024);\n  this.cubeCamera.updateMatrixWorld();\n  this.cubeCamera.renderTarget.minFilter = THREE.LinearMipMapNearestFilter;\n\n  // default texture (from wikipedia)\n  this.equirectTex = THREE.ImageUtils.loadTexture('textures/equirectangular-projection.jpg');\n  this.equirectTex.wrapS = THREE.RepeatWrapping;\n\n  /**\n   * Sphere to render equirect texture on the inside of\n   */\n  this.sphere = new THREE.Mesh(\n    new THREE.SphereGeometry(1, 100, 50),\n    new THREE.MeshBasicMaterial({\n      map: this.equirectTex,\n      side: THREE.BackSide,\n      depthWrite: false\n    })\n  );\n  this.sphere.rotation.y = this.sphereOffsetAngle;\n  this.cubeScene.add(this.sphere);\n\n  /**\n   * TOAST map\n   */\n  this.octahedron = new THREE.Mesh(\n    new PROJ.OctahedronGeometry(),\n    new THREE.ShaderMaterial({\n      vertexShader: ToastVert,\n      fragmentShader: ToastFrag,\n      uniforms: {\n        cubemap: {type: 't', value: this.cubeCamera.renderTarget}\n      }\n    })\n  );\n  this.octahedron.scale.set(2.5, 2.5, 2.5);\n  this.octahedron.position.x = -1.5;\n  this.octahedron.position.y = -2.5;\n  this.scene.add(this.octahedron);\n\n  /**\n   * Cube map\n   */\n  this.cubeSides = new CubeMapViewer(this.cubeCamera.renderTarget);\n  this.scene.add(this.cubeSides);\n  this.cubeSides.scale.set(0.4, 0.4, 0.4);\n  this.cubeSides.position.x = -0.5;\n  this.cubeSides.position.y = 1.5;\n\n  this.raycaster = new THREE.Raycaster();\n  this.mouse = new THREE.Vector2();\n\n  /**\n   * Event listeners\n   */\n  window.addEventListener('resize', this.handleWindowResize.bind(this), false);\n};\n\nDisplay.prototype.handleWindowResize = function (event) {\n  this.camera.aspect = this.container.offsetWidth/this.container.offsetHeight;\n  this.camera.updateProjectionMatrix();\n  this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n};\n\nDisplay.prototype.animate = function () {\n  this.renderer.render(this.scene, this.camera);\n  this.cubeCamera.updateCubeMap(this.renderer, this.cubeScene);\n  requestAnimationFrame(this.animate.bind(this));\n}\n\n/**\n * Downloaders\n */\nDisplay.prototype.downloadCubeMapImages = function (faceRes, done, ctx) {\n  this.cubeSides.renderToImages(this.renderer, faceRes, function () {\n    done.call(ctx);\n  }, this);\n};\n\nDisplay.prototype.downloadToastMapImage = function (faceRes) {\n  var data = this.quadRenderer.renderQuad(this.renderer, this.octahedron, faceRes, true,\n    function (blob) {\n      saveAs(blob, \"toastmap.png\");\n  });\n};\n\n/**\n * Scene interactions\n */\nDisplay.prototype.setEquirectImage = function (img) {\n  this.equirectTex.image = img;\n  this.equirectTex.needsUpdate = true;\n};\n\nDisplay.prototype.setSphereRotation = function (rot) {\n  this.sphere.rotation.y = this.sphereOffsetAngle + rot;\n};\n\nmodule.exports = Display;\n","'use strict';\n\nvar OctahedronGeometry = function () {\n  THREE.BufferGeometry.call(this);\n\n  this.type = 'OctahedronGeometry';\n\n  var positions = new Float32Array([\n     0,  1,  0, //  y\n     1,  0,  0, //  x\n    -1,  0,  0, // -x\n     0,  0,  1, //  z\n     0,  0, -1, // -z\n     0, -1,  0, // -y (split)\n     0, -1,  0, // -y (split)\n     0, -1,  0, // -y (split)\n     0, -1,  0  // -y (split)\n  ]);\n\n  // TOAST uvs\n  var uvs = new Float32Array([\n    0.5, 0.5, //  y\n    0.5, 1.0, //  x\n    0.5, 0.0, // -x\n    1.0, 0.5, //  z\n    0.0, 0.5, // -z\n\n    1.0, 1.0, // -y\n    0.0, 1.0, // -y\n    0.0, 0.0, // -y\n    1.0, 0.0  // -y\n  ]);\n\n  var indices = new Uint16Array([\n    // upper hemisphere\n    0, 3, 1,\n    0, 1, 4,\n    0, 4, 2,\n    0, 2, 3,\n\n    // lower hemisphere\n    5, 1, 3,\n    6, 4, 1,\n    7, 2, 4,\n    8, 3, 2\n  ]);\n\n\n  this.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n  this.addAttribute('index', new THREE.BufferAttribute(indices, 1));\n  this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n\n  this.computeBoundingBox();\n};\n\nOctahedronGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\nmodule.exports = OctahedronGeometry;\n","'use strict';\n\nvar OctahedronGeometry = require('./octahedronGeometry');\n\nvar QuadRenderer = function () {\n  this.setupScene();\n};\n\nQuadRenderer.prototype.setupScene = function () {\n  this.scene = new THREE.Scene();\n\n  this.camera = new THREE.OrthographicCamera(\n     -1,   1, // width\n      1,  -1, // height\n    0.5, 1.5 // near/far\n  );\n  this.camera.position.set(0, 0, 1);\n  this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n  this.camera.up.set(0, 0, 1);\n};\n\nQuadRenderer.prototype.renderQuad = function (renderer, quad, res, asBlob, done, ctx) {\n  var quadToRender = quad.clone();\n  this.scene.add(quadToRender);\n\n  if (quad.geometry instanceof OctahedronGeometry) {\n    quadToRender.position.set(-1, -1, 0);\n    quadToRender.scale.set(2, 2, 2);\n  } else {\n    quadToRender.position.set(0, 0, 0);\n  }\n\n  var originalW = renderer.domElement.width;\n  var originalH = renderer.domElement.height;\n  renderer.setSize(res, res);\n\n  renderer.render(this.scene, this.camera, false);\n\n  var data = '';\n  if (asBlob) {\n    renderer.domElement.toBlob(function (blob) {\n      done.call(ctx, blob);\n    });\n  } else {\n    data = renderer.domElement.toDataURL(\"image/png\");\n  }\n\n  // Clean up\n  this.scene.remove(quadToRender);\n  renderer.setSize(originalW, originalH);\n\n  return data;\n};\n\nmodule.exports = QuadRenderer;\n","'use strict';\n\n\n\nmodule.exports.cubeVert = \"uniform float scale;\\n\\nvarying vec3 pos;\\n\\nvec3 cube2sphere(vec3 cube) {\\n  cube /= scale;\\n\\n  float x2 = cube.x*cube.x;\\n  float y2 = cube.y*cube.y;\\n  float z2 = cube.z*cube.z;\\n  vec3 sphere = vec3(\\n    cube.x*sqrt(1.0 - y2*0.5 - z2*0.5 + y2*z2*0.3333333),\\n    cube.y*sqrt(1.0 - x2*0.5 - z2*0.5 + x2*z2*0.3333333),\\n    cube.z*sqrt(1.0 - x2*0.5 - y2*0.5 + x2*y2*0.3333333)\\n  );\\n\\n  return sphere*scale;\\n}\\n\\nvoid main() {\\n  pos = position;\\n\\n  vec3 spherePos = (modelMatrix*vec4(position, 1.0)).xyz;\\n  spherePos = cube2sphere(position);\\n\\n  gl_Position = projectionMatrix *\\n                modelViewMatrix *\\n                vec4(position, 1.0);\\n}\\n\";\nmodule.exports.cubeFrag = \"uniform samplerCube cubemap;\\nuniform vec3 side;\\n\\nvarying vec3 pos;\\n\\nvoid main() {\\n  vec3 reflDir = pos;\\n\\n  reflDir.x *= -1.0;\\n\\n  if (abs(side.x) > 0.0) {\\n    reflDir.xy = side.x < 0.0 ? vec2(reflDir.y, -reflDir.x) : reflDir.yx;\\n    reflDir.yz = reflDir.xy;\\n    reflDir.x = side.x;\\n  } else if (abs(side.y) > 0.0) {\\n    reflDir.y *= side.y > 0.0 ? 1.0 : -1.0;\\n    reflDir.xz = reflDir.xy;\\n    reflDir.y = side.y;\\n  } else if (abs(side.z) > 0.0) {\\n    reflDir.x *= side.z < 0.0 ? 1.0 : -1.0;\\n    reflDir.z = side.z;\\n  }\\n\\n  gl_FragColor = textureCube(cubemap, reflDir);\\n  // gl_FragColor = vec4(reflDir, 1.0);\\n}\";\n\nmodule.exports.toastVert = \"varying vec3 octahedronPos;\\n\\nvoid main() {\\n  octahedronPos = position;\\n\\n  gl_Position = projectionMatrix *\\n                modelViewMatrix *\\n                vec4(uv, 0.0, 1.0);\\n}\\n\";\nmodule.exports.toastFrag = \"uniform samplerCube cubemap;\\n\\nvarying vec3 octahedronPos;\\n\\n#define isqrt2 0.70710676908493042\\nvec3 cubify(vec3 s) {\\n  float xx2 = s.x*s.x*2.0;\\n  float yy2 = s.y*s.y*2.0;\\n\\n  vec2 vCube = vec2(xx2 - yy2, yy2 - xx2);\\n\\n  float ii = vCube.y - 3.0;\\n  ii *= ii;\\n\\n  float isqrt = -sqrt(ii - 12.0*xx2) + 3.0;\\n\\n  vCube = sqrt(vCube + isqrt);\\n  vCube *= isqrt2;\\n\\n  return sign(s)*vec3(vCube, 1.0);\\n}\\n\\nvec3 sphere2cube(vec3 sphere) {\\n  vec3 f = abs(sphere);\\n\\n  bool a = f.y >= f.x && f.y >= f.z;\\n  bool b = f.x >= f.z;\\n\\n  return a ? cubify(sphere.xzy).xzy : b ? cubify(sphere.yzx).zxy : cubify(sphere);\\n}\\n\\nvoid main() {\\n  vec3 reflDir = sphere2cube(normalize(octahedronPos));\\n\\n  gl_FragColor = textureCube(cubemap, reflDir);\\n}\";\n","'use strict';\n\nvar Zipper = {};\n\nZipper.zipBase64Array = function (base64Array, folderName, fileNames, callback, ctx) {\n  var zip = new JSZip();\n  Zipper.base64ArrayToBuffer(base64Array, function (buffers) {\n    buffers.forEach(function (img, idx) {\n      var name = [folderName, fileNames[idx]].join('/');\n      zip.file(name, img);\n    });\n    var blob = zip.generate({type:\"blob\"});\n    callback.call(ctx, blob);\n  });\n};\n\nZipper.zipImages = Zipper.zipBase64Array;\n\nZipper.base64ArrayToBuffer = function (base64DataArray, done, ctx) {\n  var buffers = [];\n  var buffersDone = 0;\n  base64DataArray.forEach(function (data) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', data, true);\n    xhr.responseType = \"arraybuffer\";\n    xhr.onreadystatechange = function(evt) {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          buffers.push(xhr.response);\n          buffersDone++;\n          if (buffersDone === base64DataArray.length) {\n            done.call(ctx, buffers);\n          }\n        }\n      }\n    };\n    xhr.send();\n  });\n}\n\nmodule.exports = Zipper;\n"]}